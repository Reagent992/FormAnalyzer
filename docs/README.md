# Form_Analyzer

> Это тестовое задание. \
> [Полный текст тестового задания.](./TASK.MD)

## Краткий вариант задания

Задача - создать web-приложение, которое:

1. Хранит список шаблонов форм с уникальным набором полей и их типов.
2. Принимает POST-запросы с данными формы и возвращает:
    - Имя подходящего шаблона, если он найден.
    - Типизированный список полей, если шаблон не найден.
3. Поддерживает 4 типа полей: email, телефон, дата, текст.
4. Реализует валидацию для всех типов, кроме текста.

## Личные впечатления от задания:

- До выполнения задания у меня не было опыта работы с документными базами данных. Поэтому пришлось в процессе много про них выучить. Это было интересно и полезно.
- Так же у меня не было опыта использования FastAPI.
- Главная сложность задания по моему - это сложный агрегирующий запрос в БД.
- Особенности задания: 
  - Данные приходят от веб-формы в формате `x-www-form-urlencoded`.
  - Требуется валидация для части входящих данных.
- Самое сложное для меня было - понять задание😁.
- Я написал много тестов, чтобы попрактиковаться в использование pytest.

## Используемое в проекте

| Название         | Для чего                                     |
| ---------------- | -------------------------------------------- |
| Python 3.12.7    | Последняя актуальная версия ЯП               |
| FastAPI          | RESTAPI                                      |
| MongoDB          | Основная база данных                         |
| Motor            | Асинхронный драйвер для MongoDB              |
| pytest           | Тестирование кода                            |
| pytest-asyncio   | Расширение pytest для async-кода             |
| uvicorn          | ASGI для FastAPI                             |
| email-validator  | Валидация email                              |
| python-multipart | Парсинг x-www-form-urlencoded                |
| docker           | Контейнеризация проекта для удобного запуска |


## Инструкция по запуску проекта

1. Запустить Docker контейнер с **MongoDB**.
```Docker
docker run --name mongodb -p 27017:27017 -d mongodb/mongodb-community-server:latest
```

2. Создать **virtual environment** и установить зависимости.

```
python -m venv .venv
```

```
python -m pip install -r requirements.txt
```

Для **uv**:

```
uv sync
```

3. Запустить скрипт заполнения БД

```
python fill_db.py
```

4. Запустить тесты `pytest` или запустить скрипт делающий запросы(дублирует функционал тестов, выводит все в консоль)

```
python make_testing_queries.py
```

5. Run[**Optional**]

```
uvicorn main:app --reload
```

## Dev notes

### Пример формы(документа в БД)

```JSON
{
    "_id": {"$oid": "67545524457b3467ff534420"},
    "name": "email_phone_form",
    "email_field": "email",
    "phone_field": "phone",
    "date_field": "date",
    "address_field": "text"
}
```

- `"name": "email_phone_form"` - произвольное название формы.
- `"email_field"` - произвольное название поля.
- `"address_field"` - текстовое поле, не валидируется, его название - произвольное.
- Значения `"email"`, `"phone"`, `"date"` и `"text"` это требуемые типы данных для этого поля.
- Типы данных `"email"`, `"phone"`, `"date"` - должны быть провалидированны при входящем API-запросе, а  `"text"` - нет.

### Определение входящего типа данных

Входящее поле может быть - `"email_field": "exmaple@exmaple.com"` \
Необходимо определить к какому типу данных оно принадлежит:
  1. Простой вариант - проверять наличие слова `email` в ключе.
  2. Сложный вариант - сверять каждое значение с типом данных на случай - `"почта": "exmaple@exmaple.com"`. В коде - второй вариант.

### Aggregation pipeline

1. Пошаговый пайплайн отфильтровывающий формы в бд по наличию полей из входящего API запроса. Совпадающими считаются поля, у которых совпали имя и тип значения.
2. Если в БД несколько подходящих форм:
   - Вывести форму с меньшим количеством полей.
   - А если общее количество полей одинаковое, а оставшиеся поля разные?
        - Непонятно что делать. Будем выводить просто первую.

### Что происходит если найденной формы нету

Если для входящего запроса:

```
name=John Doe&birthdate=1990-12-01&phone=+7 123 456 78 90&address=Moscow
```

Нету подходящей формы то:
1. Валидируются входящие данные в определенном порядке: дата, телефон, email, текст.
2. Эти данные возвращаются в виде `json` который определяет типы данных для полей:
```JSON
{
    "name": "text",
    "birthdate": "date",
    "phone": "phone",
    "address": "text"
}
```
> Т.е. входящие значения не возвращаются, на их месте тип этого значения. \
> `phone=+7 123 456 78 90` `->` `"phone": "phone"`
